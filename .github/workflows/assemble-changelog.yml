name: Assemble Changelog

on:
  push:
    branches: [ main ]
  workflow_dispatch:
  schedule:
    - cron: '15 5 * * *'

permissions:
  contents: write

jobs:
  changelog:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install --upgrade openai

      - name: Assemble changelog
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_KEY }}
          DEBUG: ${{ vars.CHANGELOG_DEBUG }}
          PYTHONUNBUFFERED: "1"
          REGENERATE_ALL_CHANGELOGS: ${{ vars.REGENERATE_ALL_CHANGELOGS }}
        shell: bash
        run: |
          python3 -u - <<'PY'
          import os, subprocess, re, datetime, textwrap, sys, calendar
          from pathlib import Path

          REPO = Path('.')
          CHANGES_DIR = REPO / 'docs' / 'about' / 'changes'
          WHATS_NEW = REPO / 'docs' / 'about' / 'whats-new.md'
          CHANGES_DIR.mkdir(parents=True, exist_ok=True)

          # ---------- Logging ----------
          DEBUG = os.environ.get('DEBUG', '').lower() in ('1', 'true', 'yes', 'on')
          def log(msg: str, level: str = "INFO"):
              ts = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
              print(f"[{ts}] [{level}] {msg}", flush=True)
          def dlog(msg: str):
              if DEBUG:
                  log(msg, "DEBUG")

          # Ensure shell helper 'sh' exists (fallback)
          if 'sh' not in globals():
              def sh(cmd: str) -> str:
                  return subprocess.check_output(cmd, shell=True, text=True)
              dlog("Fallback 'sh' helper definiert.")

          log("Starte Changelog-Lauf…")
          REGENERATE_ALL = os.environ.get('REGENERATE_ALL_CHANGELOGS', '').lower() in ('1','true','yes','on')
          log(f"Regeneration mode: {'ALL commits' if REGENERATE_ALL else 'ONLY new commits'}")

          # ---------- MDX Sanitizing helpers ----------
          import html
          def sanitize_for_mdx(md: str):
              """Escape MDX-hostile constructs in the body (not front matter). Returns (new_text, num_replacements)."""
              reps = 0
              # Rule A: Any "<" that does NOT start a valid HTML/MDX tag/comment/closing-tag becomes &lt;
              # Valid starters: letters, '/', '!', '?', '$', '_'
              md, nA = re.subn(r'<(?![A-Za-z\\/!\\?_\\$])', '&lt;', md)
              reps += nA
              # Rule B: Explicitly cover "<" directly before a digit (defensive; overlapped by A but kept for clarity)
              md, nB = re.subn(r'<(?=\\d)', '&lt;', md)
              reps += nB
              # Rule C: Lines that begin with a date like 2025-08-09 immediately after "<" (just in case of missed combos)
              md, nC = re.subn(r'<(?=\\d{4}-\\d{2}-\\d{2})', '&lt;', md)
              reps += nC
              # Rule D: Prevent accidental JSX from constructs like "< text" at line starts
              md, nD = re.subn(r'^(\\s*)<\\s+', r'\\1&lt; ', md, flags=re.M)
              reps += nD
              # Rule E: Balance lone ">" that are not part of tags by escaping if preceded by whitespace+digits (rare)
              md, nE = re.subn(r'(?<=\\s\\d)>', '&gt;', md)
              reps += nE
              return md, reps
          
          def split_front_matter(text: str):
              """Return (front_matter_text, body_text) if front matter is present at top, else (None, text)."""
              lines = text.splitlines(True)
              i = 0
              while i < len(lines) and lines[i].strip() == '':
                  i += 1
              if i >= len(lines) or lines[i].strip() != '---':
                  return None, text
              start = i
              i += 1
              while i < len(lines) and lines[i].strip() != '---':
                  i += 1
              if i >= len(lines):
                  # no closing fence
                  return None, text
              end = i  # line with closing ---
              fm = ''.join(lines[:end+1])
              body = ''.join(lines[end+1:])
              return fm, body

          def normalize_front_matter(text: str) -> str:
              text = text.replace('\\n', '\n')
              # Remove BOM/NUL and normalize front matter delimiters + indentation
              text = text.replace('\ufeff', '').replace('\x00', '')
              lines = text.splitlines(True)

              # find opening '---'
              i = 0
              while i < len(lines) and lines[i].strip() == '':
                  i += 1
              if not (i < len(lines) and lines[i].lstrip().startswith('---')):
                  return ''.join(lines)

              lines[i] = '---\n'
              i += 1
              while i < len(lines):
                  if lines[i].lstrip().startswith('---'):
                      lines[i] = '---\n'
                      i += 1
                      break
                  lines[i] = lines[i].lstrip(' \t')
                  i += 1

              if i < len(lines) and lines[i].strip() != '':
                  lines.insert(i, '\n')
              elif i >= len(lines):
                  lines.append('\n')
              # Ensure a blank line after closing front matter, then return
              return ''.join(lines)

          # Repair existing change files
          repaired = 0
          for p in CHANGES_DIR.glob('*.md'):
              try:
                  raw = p.read_text(encoding='utf-8')
                  fixed = normalize_front_matter(raw)
                  # Sanitize body for MDX safety
                  fm, body = split_front_matter(fixed)
                  if fm is None:
                      # No front matter detected; sanitize whole text as a fallback
                      body_sanitized, s_count = sanitize_for_mdx(fixed)
                      new_text = body_sanitized
                  else:
                      body_sanitized, s_count = sanitize_for_mdx(body)
                      new_text = (fm + body_sanitized)
                  changed = (new_text != raw)
                  if changed:
                      p.write_text(new_text, encoding='utf-8')
                      repaired += 1
                      dlog(f"Front-Matter/MDX repariert: {p} (Sanitizations: {s_count})")
              except Exception:
                  pass

          log(f"{repaired} bestehende Dateien repariert.")

          def existing_shas() -> set[str]:
              shas = set()
              for p in CHANGES_DIR.glob('*.md'):
                  m = re.fullmatch(r'(?:\\d{4}-\\d{2}-\\d{2}-)?([0-9a-f]{40})\\.md', p.name)
                  if m:
                      shas.add(m.group(1))
                      continue
                  try:
                      txt = p.read_text(encoding='utf-8')
                      m2 = re.search(r'^sha:\\s*\"?([0-9a-f]{40})\"?\\s*$', txt, flags=re.M)
                      if m2:
                          shas.add(m2.group(1))
                  except Exception:
                      pass
              return shas

          def get_commits():
              fmt = '%H\\x1f%an\\x1f%ad\\x1f%s'
              out = sh(f"git log --date=iso --pretty=format:'{fmt}'")
              commits = []
              for line in out.splitlines():
                  sha, author, adate, subject = line.split('\\x1f')
                  commits.append({'sha': sha, 'author': author, 'date': adate, 'subject': subject})
              return commits

          def get_commit_files(sha: str):
              out = sh(f"git diff-tree -m --no-commit-id --name-only -r {sha}")
              return [ln.strip() for ln in out.splitlines() if ln.strip()]

          def get_diff(sha: str) -> str:
              try:
                  diff = sh(f"git show -m {sha} --pretty=format: --unified=3")
              except subprocess.CalledProcessError:
                  diff = ''
              return diff[:50000]

          def is_merge_commit(sha: str) -> bool:
              try:
                  parents = sh(f"git show -s --format=%P {sha}").split()
                  return len(parents) >= 2
              except Exception:
                  return False

          # ---------- OpenAI ----------
          from openai import OpenAI
          client = OpenAI()

          SYSTEM = (
              "You are a release-note writer focusing ONLY on non-technical documentation changes.\n"
              "Scope to include:\n"
              "- Documentation content updates (wording, sections, pages, examples)\n"
              "- Information architecture & navigation (sidebars, categories, slugs)\n"
              "- Governance/policies, naming conventions, versioning/structure visible to readers\n"
              "- Visual/UX of docs site that affects readers (headings, TOC, landing pages)\n"
              "Explicitly EXCLUDE:\n"
              "- Source code, pipelines, build tweaks, formatting-only diffs, dependency bumps, lockfiles\n"
              "- Internal refactors that do not change rendered docs\n"
              "- Pure CI/.github changes unless they alter what end users/readers see\n"
              "\n"
              "Output style (Markdown):\n"
              "- 5–10 bullet points MAX, each describing ONE non-technical change.\n"
              "- Each bullet starts with an impact tag: **[Impact: High|Medium|Low]**.\n"
              "- Each bullet must be categorized as one of: Content update, Navigation change, Naming/terminology, Data update, Governance/access (add in parentheses after the impact tag).\n"
              "- Be specific and plain-English; no marketing language, no emojis.\n"
              "- After each bullet, add two links:\n"
              "   1. [details](/docs/about/changes/<markdown_date_filename>)\n"
              "   2. [commit](https://github.com/TheTrustedAdvisor/FabricAdoptionFramework/commit/<sha>)\n"
              "- Do NOT include raw diffs or code fences of +/-.\n"
              "- End with a single sentence starting with 'Why it matters:' that synthesises the overall effect.\n"
          )

          TITLE_SYSTEM = (
              "You create ultra-short, informative English titles for commit-level change logs.\n"
              "- 3–8 words, no ending period, no emojis.\n"
              "- Capture the essence of the change as seen by documentation readers.\n"
              "- Prefer wording that reflects docs structure/content/navigation over code/process.\n"
              "- Avoid generic words like 'update', 'changes', 'stuff'.\n"
          )

          def make_short_title(subject: str, files: list[str], diff_snippet: str) -> str:
              seed = "Files: " + ", ".join(files[:12]) if files else "Files: n/a"
              prompt = (
                  "Write a 3–8 word English title that summarises the commit.\n"
                  "Be specific. Avoid generic words. No emojis, no trailing dot.\n\n"
                  f"Subject: {subject}\n"
                  f"{seed}\n"
                  "Diff (truncated, for context only):\n---\n"
                  f"{diff_snippet[:2000]}\n---\n"
              )
              t = call_model(TITLE_SYSTEM, prompt)
              # one line, strip Markdown code fences just in case
              return t.strip().strip("#").strip()

          def call_model(system: str, user: str) -> str:
              resp = client.chat.completions.create(
                  model="gpt-4o-mini",
                  temperature=0.4,
                  messages=[{"role":"system","content":system},{"role":"user","content":user}],
              )
              return resp.choices[0].message.content.strip()

          def build_commit_markdown(sha, author, date, subject, body_md, merge: bool, title_line: str) -> str:
              sanitized_subject = subject.replace('"', '\\"')
              lines = []
              lines.append('---')
              lines.append(f'sha: "{sha}"')
              lines.append(f'author: "{author}"')
              lines.append(f'date: "{date}"')
              lines.append(f'subject: "{sanitized_subject}"')
              lines.append(f'merge: {"true" if merge else "false"}')
              lines.append('---')
              lines.append('')
              # Commit link at top
              lines.append(f"[View commit on GitHub](https://github.com/TheTrustedAdvisor/FabricAdoptionFramework/commit/{sha})")
              lines.append('')
              # Short intro paragraph
              # Compose a summary sentence from the subject line
              intro = f"This commit: {subject.strip()}"
              lines.append(intro)
              lines.append('')
              # H1 title
              lines.append(f"# {title_line}")
              lines.append('')
              # Body
              lines.append(body_md.strip())
              lines.append('')
              return "\n".join(lines)

          created = []
          existing = existing_shas()
          log(f"{len(existing)} bereits vorhandene Commit-Dateien erkannt.")
          commits = get_commits()
          log(f"{len(commits)} Commits im Repository gefunden.")
          skipped_existing = 0
          skipped_workflow_only = 0
          processed = 0
          for idx, c in enumerate(commits, 1):
              sha = c['sha']
              subject = c['subject']
              log(f"[{idx}/{len(commits)}] Prüfe Commit {sha[:7]} – {subject}")
              if (not REGENERATE_ALL) and (sha in existing):
                  skipped_existing += 1
                  dlog(f"Übersprungen (bereits vorhanden): {sha[:7]}")
                  continue
              files = get_commit_files(sha)
              if files and all(f.startswith('.github/') for f in files):
                  skipped_workflow_only += 1
                  dlog(f"Übersprungen (nur Workflow-Dateien): {sha[:7]}")
                  continue
              diff = get_diff(sha)
              dlog(f"Diff-Länge: {len(diff)} Zeichen")
              # Build dynamic English title: "Changes – YYYY-MM-DD: <short title> (<shortsha>)"
              date_prefix = c['date'].split(' ')[0]
              short_title = make_short_title(subject, files, diff)
              title_line = f"Changes – {date_prefix}: {short_title} ({sha[:7]})"
              user_prompt = textwrap.dedent(f"""
              Commit: {sha}
              Autor: {c['author']}
              Datum: {c['date']}
              Betroffene Dateien (Auszug): {', '.join(files[:20]) if files else 'k.A.'}

              Commit-Betreff: {subject}

              Hier der technische Diff (nur fuer dich zur Analyse, **nicht** als Ausgabe uebernehmen):
              ---
              {diff}
              ---

              Aufgabe: Schreibe eine kurze, gut lesbare Zusammenfassung (Markdown) NUR zu NICHT‑TECHNISCHEN Änderungen, die Leser*innen der Dokumentation betreffen (Inhalte, Struktur, Navigation, Benennung, Governance).
              Anforderungen:
              - Max. 10 Bulletpoints, klar und prägnant
              - JEDER Bullet beginnt mit **[Impact: High|Medium|Low]**
              - Kein DIFF, keine Code-Blöcke mit +/-; keine Build-/Pipeline-/Refactor-Details
              - Ignoriere rein technische Änderungen, die keine sichtbare Auswirkung auf die Doku haben
              - Wenn nichts Relevantes für Leser*innen geändert wurde, antworte mit einem einzigen Bullet **[Impact: Low] No reader-visible documentation changes.**
              - Schließe mit einem kurzen Satz: "Why it matters: …" (kurz begründen)
              """)
              dlog("Calling OpenAI for English body…")
              # Force English in the user prompt.
              user_prompt = "Write the following summary in ENGLISH.\n\n" + user_prompt
              body_md = call_model(SYSTEM, user_prompt)
              body_md, s_new = sanitize_for_mdx(body_md)
              dlog(f"MDX sanitize for new file: {s_new} replacements")
              filename = f"{date_prefix}-{sha}.md"
              out_path = CHANGES_DIR / filename
              merge_flag = is_merge_commit(sha)
              out_path.write_text(
                  build_commit_markdown(sha, c['author'], c['date'], subject, body_md, merge_flag, title_line),
                  encoding='utf-8'
              )
              created.append(out_path)
              processed += 1
              log(f"✅ Datei erstellt: {out_path.name}")

          # Build what's-new as monthly PROSE using OpenAI (author voice), linking to /about/changes/...
          TECH_KEYWORDS = re.compile(r'\b(chore|refactor|ci|build|workflow|vercel|action|deps?|dependency|package[- ]?lock|yarn.lock|pnpm-lock|bump|lint|format|prettier|tsconfig|webpack|eslintrc|jest|vitest|gh[- ]?actions)\b', re.I)

          def looks_technical(e: dict, body_text: str = "") -> bool:
              hay = " ".join([
                  e.get('title',''),
                  e.get('subject',''),
                  e.get('path','') if isinstance(e.get('path'), str) else e.get('path').name
              ])
              if TECH_KEYWORDS.search(hay):
                  return True
              if 'No reader-visible documentation changes' in body_text:
                  return True
              return False

          def read_entry(p: Path) -> dict:
              txt = p.read_text(encoding='utf-8')
              msha = re.search(r'^sha:\s*("?)([0-9a-f]{40})\1$', txt, flags=re.M)
              msub = re.search(r'^subject:\s*"?(.+?)"?\s*$', txt, flags=re.M)
              mdate = re.search(r'^date:\s*(.+)$', txt, flags=re.M)
              mhead = re.search(r'^#\s+(.+)$', txt, flags=re.M)
              teaser = (mhead.group(1).strip() if mhead else (msub.group(1).strip() if msub else '')).strip()
              return {
                  'sha': (msha.group(2) if msha else p.stem),
                  'subject': (msub.group(1).strip() if msub else ''),
                  'date': (mdate.group(1).strip() if mdate else ''),
                  'title': teaser,
                  'path': p,
                  'raw': txt
              }

          def month_label(ym: str) -> str:
              if ym == "unknown":
                  return "Unknown"
              y, m = ym.split('-')
              month_name = calendar.month_name[int(m)]  # English month names
              return f"{month_name} {y}"

          def mdx_safe(s: str) -> str:
              return s.replace('<','&lt;').replace('>','&gt;')

          def summarize_month_with_ai(month_name: str, items: list[dict]) -> str:
              """
              Use OpenAI to write 2–3 warm, author-voice paragraphs summarizing NON-technical changes.
              Each highlighted change should end its sentence with (Read more ›) linking to the exact detail page.
              """
              # Prepare a compact catalog for the model with exact URLs it must reuse verbatim.
              # Link path FIX: /about/changes/{filename}
              catalog_lines = []
              for e in items:
                  filename = e['path'].name
                  url = f"/about/changes/{filename}"
                  title = e['title'] or e['subject'] or filename
                  catalog_lines.append(f"- {mdx_safe(title)} — {url}")

              catalog = "\n".join(catalog_lines)
              user = textwrap.dedent(f"""
              You are writing the monthly "What's new" section for the Fabric Adoption Framework website.

              WRITE IN ENGLISH, in the first person singular, as the author speaking directly to readers.
              Tone: personal, warm, enthusiastic — like giving readers a friendly hug.
              Include ONLY non-technical documentation changes (content, structure, navigation, naming, governance, reader-facing UX). 
              Ignore anything purely technical (code refactors, CI/CD, build, dependencies, lockfiles).

              For the month **{month_name}**, write 2–3 short paragraphs explaining:
              - what changed (focus on readers' perspective),
              - why it matters,
              - what impact we expect.
              Where relevant, thank contributors or the community.

              IMPORTANT LINKING RULE:
              You MUST incorporate some of the items below in the prose.
              When you mention a specific change, end that sentence with a Markdown link exactly as:
              (Read more ›)
              and use the exact URL provided next to the item.

              Available items (Title — URL):
              {catalog}

              Constraints:
              - No bullet lists. Write flowing paragraphs only.
              - Keep it concise and authentic. No marketing buzzwords. No emojis.
              - If there are no reader-visible changes in this month, write one sentence: 
                "This month, there were no reader-visible documentation changes."
              """).strip()

              try:
                  text = call_model(
                      "You write monthly 'What's new' summaries in warm, authentic author voice for a documentation website. You strictly exclude technical-only changes.",
                      user
                  )
              except Exception as ex:
                  dlog(f"OpenAI month summary failed: {ex}")
                  # Fallback simple prose
                  if not items:
                      return f"For {month_name}, there were no reader-visible documentation changes."
                  joined = "; ".join(mdx_safe(e['title'] or e['subject'] or e['path'].stem) for e in items[:4])
                  return f"In {month_name}, I focused on refining our documentation: {joined}. (Read more ›)"

              # MDX-sanitize minimally
              text, _ = sanitize_for_mdx(text)
              return text.strip()

          log("Erzeuge 'whats-new.md'…")
          all_change_files = sorted(CHANGES_DIR.glob('*.md'))
          if all_change_files:
              # sort by git log order (newest first)
              order_map = {c['sha']: i for i, c in enumerate(commits)}
              def sort_key(p: Path):
                  m = re.fullmatch(r'(?:\d{4}-\d{2}-\d{2}-)?([0-9a-f]{40})', p.stem)
                  key_sha = m.group(1) if m else p.stem
                  return order_map.get(key_sha, 10**9)
              ordered = sorted(all_change_files, key=sort_key, reverse=True)

              entries = [read_entry(p) for p in ordered]

              # group by YYYY-MM, filter out technical
              by_month: dict[str, list[dict]] = {}
              for e in entries:
                  # Derive YYYY-MM from front matter date or filename
                  m = re.search(r'^(\d{4})-(\d{2})-(\d{2})', e['date'])
                  if not m:
                      m = re.search(r'^(\d{4})-(\d{2})-(\d{2})', e['path'].name)
                  ym = f"{m.group(1)}-{m.group(2)}" if m else "unknown"
                  if looks_technical(e, e['raw']):
                      dlog(f"Filter technical from What's new: {e['path'].name}")
                      continue
                  by_month.setdefault(ym, []).append(e)

              # Prepare front matter and badge
              latest_entry = next((e for e in entries if e.get('date')), None)
              latest_date = latest_entry['date'].split()[0] if latest_entry else ''
              badge = f"![Last updated](https://img.shields.io/badge/last%20updated-{latest_date.replace('-', '--')}-brightgreen)" if latest_date else ''

              fm = [
                  "---",
                  "id: whats-new",
                  "title: What's new",
                  "sidebar_label: What's new",
                  "description: Monthly highlights of documentation changes in the Fabric Adoption Framework.",
                  "---",
                  "",
              ]

              parts = []
              parts.extend(fm)
              if badge:
                  parts.append(badge)
                  parts.append("")

              parts.append("# What's new")
              parts.append("")

              # newest month first
              for ym in sorted(by_month.keys(), reverse=True):
                  month_items = by_month[ym][:12]
                  if not month_items:
                      continue
                  label = month_label(ym)
                  parts.append(f"## {label}")
                  parts.append("")
                  # Generate warm prose for this month
                  prose = summarize_month_with_ai(label, month_items)
                  parts.append(prose)
                  parts.append("")

              WHATS_NEW.parent.mkdir(parents=True, exist_ok=True)
              content = "\n".join(parts).strip() + "\n"
              WHATS_NEW.write_text(content, encoding='utf-8')
              log(f"'whats-new.md' updated with monthly prose (months: {len(by_month)})")

          log(f"FERTIG. Neue Dateien: {len(created)} | Repariert: {repaired} | Übersprungen (vorhanden): {skipped_existing} | Übersprungen (.github): {skipped_workflow_only} | Gesamt-Commits: {len(commits)}")
          dlog(f"REGENERATE_ALL_CHANGELOGS={os.environ.get('REGENERATE_ALL_CHANGELOGS')!r}")
          log("Changelog-Lauf abgeschlossen.")
          PY

      - name: Commit and push changes
        shell: bash
        run: |
          bash -euo pipefail <<'BASH'
          set -x
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add -A docs/about/changes docs/about/whats-new.md || true
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "docs(changelog): update whats-new and per-commit entries [skip ci]"
            git push
          fi
          BASH